import * as dydx from '@dydxprotocol/v3-client'
import {
    KeyPairWithYCoordinate,
    keyPairFromData,
} from '@dydxprotocol/starkex-lib';
//import Web3 from 'web3';
const log = require('simple-node-logger').createSimpleLogger('project.log');
const path = require('path')
require('dotenv').config({ path: path.resolve(__dirname, './../.env') })

const Web3 = require("web3");
const WebSocket = require('ws')


const HTTP_HOST_MAINNET = 'https://api.dydx.exchange'
const HTTP_HOST_ROPSTEN = 'https://api.stage.dydx.exchange'
const WS_HOST_MAINNET = 'wss://api.stage.dydx.exchange/v3/ws' //mainnet: wss://api.dydx.exchange/v3/ws
const WS_HOST_ROPSTEN = 'wss://api.dydx.exchange/v3/ws'


const UI_URL_TESTNET = "https://trade.stage.dydx.exchange/portfolio/overview"
const UI_URL_MAINNET = "https://trade.dydx.exchange/portfolio/overview"


export enum NetworkID {
    MainNet = 1,
    RopstenTestNet = 3
}

export class Connector {

    static _client: dydx.DydxClient
    _positionID: string

    private constructor(
        networkId: NetworkID = NetworkID.RopstenTestNet,
        keyPair: KeyPairWithYCoordinate,
        apiCreds: dydx.ApiKeyCredentials
    ) {
        const web3 = new Web3(process.env.MORALIS)
        //web3.eth.accounts.wallet.add(process.env.ETH_PRIVATE_KEY)

        const host = networkId === 1 ? HTTP_HOST_MAINNET : HTTP_HOST_ROPSTEN
        Connector._client = new dydx.DydxClient(
            host,
            {
                apiTimeout: 3000,
                networkId: networkId,
                web3: web3,

                starkPrivateKey: keyPair,
                apiKeyCredentials: apiCreds
            }

        );
    }

    public get client(): dydx.DydxClient {
        return Connector._client
    }

    public get positionID(): string {
        return this._positionID
    }

    public set positionID(id: string) {
        this._positionID = id
    }


    static async build(
        networkId: NetworkID = NetworkID.RopstenTestNet,
    ): Promise<Connector> {
        let connector: Connector
        let keyPair: KeyPairWithYCoordinate
        let apiCreds: dydx.ApiKeyCredentials
        if (!Connector.checkIfEthPrivateKeyPresent()) {
            if (!Connector.checkIfAllRequiredKeysPresent()) return
            else {
                keyPair = {
                    privateKey: process.env.STARK_PRIVATE_KEY,
                    publicKey: process.env.STARK_PUBLIC_KEY,
                    publicKeyYCoordinate: process.env.STARK_COORD
                }
                 apiCreds = {
                    key: process.env.DYDX_API_KEY,
                    passphrase: process.env.DYDX_PASSPHRASE,
                    secret: process.env.DYDX_SECRET
                }
            }

        } else {
            const web3 = new Web3(process.env.MORALIS)
            web3.eth.accounts.wallet.add(process.env.ETH_PRIVATE_KEY)

            const host = networkId === 1 ? HTTP_HOST_MAINNET : HTTP_HOST_ROPSTEN
            Connector._client = new dydx.DydxClient(
                host,
                {
                    apiTimeout: 3000,
                    networkId: networkId,
                    web3: web3,
                }
            );

            keyPair = await Connector.getKeyPairWithYCoordinate()
            apiCreds = await Connector.getApiCredentials()
        }
        connector = new Connector(networkId, keyPair, apiCreds)
        connector.positionID = (await connector.getAccount()).positionId

        return connector

    }

    public static checkGeneralKeysPresent() {
        if (!Connector.checkIfEthPrivateKeyPresent()) {
            if (!Connector.checkIfAllRequiredKeysPresent()) return false
        }
        return true
    }

    private static checkIfAllRequiredKeysPresent() {
        let keys = [process.env.STARK_PRIVATE_KEY, process.env.STARK_PUBLIC_KEY, process.env.STARK_COORD, process.env.DYDX_API_KEY, process.env.DYDX_PASSPHRASE, process.env.DYDX_SECRET]

        for (const key in keys) {
            if (key !== undefined) {
                return true
            } else {
                console.log("Keys missing")
                return false
            }
        }
    }

    private static checkIfEthPrivateKeyPresent() {
        let key = process.env.ETH_PRIVATE_KEY
        if (key !== undefined) {
            console.log("Private Key found")
            return true
        } else {
            console.log("Private Key missing")
            return false
        }
    }

    public getPNLInPercent(position: dydx.PositionResponseObject): Number {
        return (Number(position.unrealizedPnl) * 100) / (Number(position.size) * Number(position.entryPrice))
    }

    /**
     * 
     * @param side BUY, SELL
     * @param type  LIMIT, MARKET, STOP_LIMIT, TRAILING_STOP, TAKE_PROFIT
     * @param timeInForce GTT, FOK, IOC"
     * @param postOnly best to keep at false, dunno what this is doing
     * @param size of token
     * @param price you want to buy for
     * @param limitFee 
     * @param expiration date of your order
     * @param market DydxMarketEnum e.g. BTC_USD 
     * @returns Promise<dydx.OrderResponseObject> 
     */
    public async createOrder(
        side: dydx.OrderSide,
        type: dydx.OrderType,
        timeInForce: dydx.TimeInForce,
        postOnly: boolean = false,
        size: string,
        price: string,
        limitFee: string = '0.015',
        expiration: string = '2022-12-21T21:30:20.200Z',
        market: dydx.Market,

    ): Promise<dydx.OrderResponseObject> {
        try {
            const result: { order: dydx.OrderResponseObject } = await this.client.private.createOrder(
                {
                    side,
                    type,
                    timeInForce,
                    postOnly,
                    size,
                    price,
                    limitFee,
                    expiration,
                    market,
                },
                this.positionID
            );
            console.log("New order placed!")
            log.info("Order placed: ", result.order)
            return result.order
        } catch (error) {
            console.log(error)
        }

    }

    public async getPositions(
        market: dydx.Market = undefined,
        status: dydx.PositionStatus = undefined
    ): Promise<dydx.PositionResponseObject[]> {
        try {
            const result = await this.client.private.getPositions(
                {
                    market: market,
                    status: status,
                },
            );
            return result.positions
        }
        catch (error) {
            console.log(error)
        }
    }


    public async getOrders(
        market: dydx.Market = undefined,
        status: dydx.OrderStatus = dydx.OrderStatus.OPEN,
        side: dydx.OrderSide = undefined,
        type: dydx.OrderType = undefined,
        limit: number = 50): Promise<dydx.OrderResponseObject[]> {

        try {
            const result: { orders: dydx.OrderResponseObject[] } = await this.client.private.getOrders(
                {
                    market: market,
                    status: status,
                    side: side,
                    type: type,
                    limit: limit,
                },
            );
            return result.orders
        }
        catch (error) {
            console.log(error)
        }
    }

    public async getOrderById(id: string): Promise<dydx.OrderResponseObject> {
        try {
            const result: { order: dydx.OrderResponseObject } = await this.client.private.getOrderById(id);
            return result.order
        }
        catch (error) {
            console.log(error)
        }
    }

    public async getActiveOrder(market: dydx.Market): Promise<dydx.ActiveOrderResponseObject[]> {
        try {
            const result: { orders: dydx.ActiveOrderResponseObject[], } = await this.client.private.getActiveOrders(market);
            return result.orders
        }
        catch (error) {
            console.log(error)
        }
    }

    public async recoverInfo() {
        const recovery: {
            starkKey: string
        } = await Connector._client.ethPrivate.recovery(
            process.env.ETH_ADDRESS,
        );

        return recovery
    }

    public async registerNewUser(keyPair: KeyPairWithYCoordinate) {
        const onboardingInformation: {
            apiKey: dydx.ApiKeyCredentials,
            user: dydx.UserResponseObject,
            account: dydx.AccountResponseObject,
        } = await Connector._client.onboarding.createUser(
            {
                starkKey: keyPair.publicKey,
                starkKeyYCoordinate: keyPair.publicKeyYCoordinate,
                country: 'DE',
            },
            process.env.ETH_ADDRESS,
        );

        return onboardingInformation
    }

    public static async getApiCredentials(): Promise<dydx.ApiKeyCredentials> {
        try {
            const apiCreds = await Connector._client.onboarding.recoverDefaultApiCredentials(
                process.env.ETH_ADDRESS)

            return apiCreds;
        }
        catch (error) {
            console.log(error)
        }
    }

    public static async getKeyPairWithYCoordinate(): Promise<KeyPairWithYCoordinate> {
        try {
            const keyPairWithYCoordinate: KeyPairWithYCoordinate = await Connector._client.onboarding.deriveStarkKey(
                process.env.ETH_ADDRESS,
            );

            return keyPairWithYCoordinate;
        }
        catch (error) {
            console.log(error)
        }
    }

    public async updateUser(email: string, username: string, country: string): Promise<dydx.UserResponseObject> {
        try {
            const result: { user: dydx.UserResponseObject } = await this.client.private.updateUser({
                email,
                username,
                isSharingAddress: false,
                userData: {},
                country,
            });
            return result.user;
        }
        catch (error) {
            console.log(error)
        }
    }

    public async getAccount(): Promise<dydx.AccountResponseObject> {
        try {
            const result: { account: dydx.AccountResponseObject } = await this.client.private.getAccount(
                process.env.ETH_ADDRESS,
            );
            return result.account
        }
        catch (error) {
            console.log(error)
        }
    }

    public async getUser(): Promise<dydx.UserResponseObject> {
        try {
            const result: { user: dydx.UserResponseObject } = await this.client.private.getUser();
            return result.user
        }
        catch (error) {
            console.log(error)
        }
    }
}


export {Connector as DYDXConnector}