import { Contracts } from '../lib/Contracts';
import { Address, BigNumberable, CallOptions, SendOptions, TxResult, ZeroExSwapResponse } from '../types';
export declare class Exchange {
    protected contracts: Contracts;
    constructor(contracts: Contracts);
    getAddress(): string;
    getProxyDepositAddress(): string;
    register({ ethAddress, starkKey, signature, }: {
        ethAddress: Address;
        starkKey: string;
        signature: string;
    }, options?: SendOptions): Promise<TxResult>;
    registerAndDeposit({ ethAddress, starkKey, signature, positionId, humanAmount, }: {
        ethAddress: Address;
        starkKey: string;
        signature: string;
        positionId: BigNumberable;
        humanAmount: BigNumberable;
    }, options?: SendOptions): Promise<TxResult>;
    deposit({ starkKey, positionId, humanAmount, }: {
        starkKey: string;
        positionId: BigNumberable;
        humanAmount: BigNumberable;
    }, options?: SendOptions): Promise<TxResult>;
    proxyDeposit({ humanAmount, starkKey, positionId, }: {
        humanAmount: string;
        starkKey: string;
        positionId: BigNumberable;
    }, options?: SendOptions): Promise<TxResult>;
    approveSwap({ tokenFrom, allowanceTarget, }: {
        tokenFrom: string;
        allowanceTarget: string;
    }, options?: SendOptions): Promise<TxResult>;
    proxyDepositERC20({ humanMinUsdcAmount, starkKey, positionId, zeroExResponseObject, }: {
        humanMinUsdcAmount: string;
        starkKey: string;
        positionId: BigNumberable;
        zeroExResponseObject: ZeroExSwapResponse;
    }, options?: SendOptions): Promise<TxResult>;
    approveSwapAndProxyDepositERC20({ humanMinUsdcAmount, starkKey, positionId, zeroExResponseObject, }: {
        humanMinUsdcAmount: string;
        starkKey: string;
        positionId: BigNumberable;
        zeroExResponseObject: ZeroExSwapResponse;
    }, options?: SendOptions): Promise<TxResult>;
    proxyDepositEth({ starkKey, positionId, zeroExResponseObject, }: {
        starkKey: string;
        positionId: BigNumberable;
        zeroExResponseObject: ZeroExSwapResponse;
    }, options?: SendOptions): Promise<TxResult>;
    /**
     * @description get expected and worst USDC for some amount of input sellToken.
     * @notice For eth pass in 'ETH' as the sellToken.
     */
    estimateConversionAmount({ humanSellAmount, sellToken, slippageFraction, }: {
        humanSellAmount: string;
        sellToken: string;
        slippageFraction?: string;
    }): Promise<{
        expectedUsdcHumanAmount: string;
        worstUsdcHumanAmount: string;
        zeroExResponseObject: ZeroExSwapResponse;
    }>;
    withdraw({ starkKey, }: {
        starkKey: string;
    }, options?: SendOptions): Promise<TxResult>;
    withdrawTo({ starkKey, recipient, }: {
        starkKey: string;
        recipient: Address;
    }, options?: SendOptions): Promise<TxResult>;
    forcedWithdrawalRequest({ starkKey, positionId, humanAmount, premiumCost, }: {
        starkKey: string;
        positionId: BigNumberable;
        humanAmount: BigNumberable;
        premiumCost: boolean;
    }, options?: SendOptions): Promise<TxResult>;
    getEthKey({ starkKey, }: {
        starkKey: string;
    }, options?: CallOptions): Promise<string | null>;
    getWithdrawalBalance({ starkKey, }: {
        starkKey: string;
    }, options?: CallOptions): Promise<string>;
    hasCancellationRequest({ starkKey, vaultId, }: {
        starkKey: string;
        vaultId: BigNumberable;
    }, options?: CallOptions): Promise<boolean>;
    hasForcedWithdrawalRequest({ starkKey, positionId, humanAmount, }: {
        starkKey: string;
        positionId: BigNumberable;
        humanAmount: BigNumberable;
    }, options?: CallOptions): Promise<boolean>;
}
