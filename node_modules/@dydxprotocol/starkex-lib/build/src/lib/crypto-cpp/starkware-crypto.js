"use strict";
/////////////////////////////////////////////////////////////////////////////////
// Copyright 2019 StarkWare Industries Ltd.                                    //
//                                                                             //
// Licensed under the Apache License, Version 2.0 (the "License").             //
// You may not use this file except in compliance with the License.            //
// You may obtain a copy of the License at                                     //
//                                                                             //
// https://www.starkware.co/open-source-license/                               //
//                                                                             //
// Unless required by applicable law or agreed to in writing,                  //
// software distributed under the License is distributed on an "AS IS" BASIS,  //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    //
// See the License for the specific language governing permissions             //
// and limitations under the License.                                          //
/////////////////////////////////////////////////////////////////////////////////
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPublicKey = exports.sign = exports.verify = exports.pedersen = void 0;
// Modified by dYdX:
// - convert to TypeScript
// - throw instead of chai assert
// - other superficial updates
// - get library path locally
// - return dummy proxy if the library fails to load
const BigIntBuffer = __importStar(require("bigint-buffer"));
const CRYPTO_CPP_LIB = 'libcrypto_c_exports';
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let libcrypto = new Proxy({}, {
    get() {
        throw new Error('Crypto c++ library not found or not supported on this platform');
    },
});
try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires, global-require
    const ffi = require('ffi-napi');
    libcrypto = ffi.Library(`${__dirname}/${CRYPTO_CPP_LIB}`, {
        Hash: ['int', ['string', 'string', 'string']],
        Verify: ['bool', ['string', 'string', 'string', 'string']],
        Sign: ['int', ['string', 'string', 'string', 'string']],
        GetPublicKey: ['int', ['string', 'string']],
    });
}
catch {
    // eslint: Intentionally empty.
}
/**
 * Computes the Starkware version of the Pedersen hash of x and y.
 * Full specification of the hash function can be found here:
 *  https://starkware.co/starkex/docs/signatures.html#pedersen-hash-function
 */
function pedersen(x, y) {
    const xBuf = BigIntBuffer.toBufferLE(x, 32);
    const yBuf = BigIntBuffer.toBufferLE(y, 32);
    const resBuf = Buffer.alloc(1024);
    const res = libcrypto.Hash(xBuf, yBuf, resBuf);
    if (res !== 0) {
        throw new Error(`libcrypto.Hash: ${resBuf.toString()}`);
    }
    return BigIntBuffer.toBigIntLE(resBuf);
}
exports.pedersen = pedersen;
/**
 * Verifies ECDSA signature of a given hash message with a given public key.
 * Returns true if publicKey signs the message.
 * NOTE: This function assumes that the publicKey is on the curve.
 */
function verify(starkKey, message, r, s) {
    const starkKeyBuf = BigIntBuffer.toBufferLE(starkKey, 32);
    const messageBuf = BigIntBuffer.toBufferLE(message, 32);
    const rBuf = BigIntBuffer.toBufferLE(r, 32);
    const sBuf = BigIntBuffer.toBufferLE(s, 32);
    return libcrypto.Verify(starkKeyBuf, messageBuf, rBuf, sBuf);
}
exports.verify = verify;
/**
 * Signs message hash z with the provided privateKey, with randomness k.
 * NOTE: k should be a strong cryptographical random, and not repeat.
 */
function sign(privateKey, message, k) {
    const privateKeyBuf = BigIntBuffer.toBufferLE(privateKey, 32);
    const messageBuf = BigIntBuffer.toBufferLE(message, 32);
    const kBuf = BigIntBuffer.toBufferLE(k, 32);
    const resBuf = Buffer.alloc(1024);
    const res = libcrypto.Sign(privateKeyBuf, messageBuf, kBuf, resBuf);
    if (res !== 0) {
        throw new Error(`libcrypto.Sign: ${resBuf.toString()}`);
    }
    const r = BigIntBuffer.toBigIntLE(resBuf.slice(0, 32));
    const s = BigIntBuffer.toBigIntLE(resBuf.slice(32, 64));
    return { r, s };
}
exports.sign = sign;
/**
 * Deduces the public key given a private key.
 * The x coordinate of the public key is also known as the partial public key,
 * and used in StarkEx to identify the user.
 */
function getPublicKey(privateKey) {
    const privateKeyBuf = BigIntBuffer.toBufferLE(privateKey, 32);
    const resBuf = Buffer.alloc(1024);
    const res = libcrypto.GetPublicKey(privateKeyBuf, resBuf);
    if (res !== 0) {
        throw new Error(`libcrypto.GetPublicKey: ${resBuf.toString()}`);
    }
    return BigIntBuffer.toBigIntLE(resBuf);
}
exports.getPublicKey = getPublicKey;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3Rhcmt3YXJlLWNyeXB0by5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9saWIvY3J5cHRvLWNwcC9zdGFya3dhcmUtY3J5cHRvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjtBQUNqRixpRkFBaUY7QUFDakYsaUZBQWlGO0FBQ2pGLGlGQUFpRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVqRixvQkFBb0I7QUFDcEIsMEJBQTBCO0FBQzFCLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLG9EQUFvRDtBQUVwRCw0REFBOEM7QUFFOUMsTUFBTSxjQUFjLEdBQUcscUJBQXFCLENBQUM7QUFFN0MsOERBQThEO0FBQzlELElBQUksU0FBUyxHQUFRLElBQUksS0FBSyxDQUFDLEVBQUUsRUFBRTtJQUNqQyxHQUFHO1FBQ0QsTUFBTSxJQUFJLEtBQUssQ0FDYixnRUFBZ0UsQ0FDakUsQ0FBQztJQUNKLENBQUM7Q0FDRixDQUFDLENBQUM7QUFFSCxJQUFJO0lBQ0YsOEVBQThFO0lBQzlFLE1BQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUVoQyxTQUFTLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FDckIsR0FBRyxTQUFTLElBQUksY0FBYyxFQUFFLEVBQ2hDO1FBQ0UsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUM3QyxNQUFNLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFR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